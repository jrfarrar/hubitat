/**
 *  Shelly BLU Distance MQTT Device Handler
 *
 *  Modified from BI MQTT Motion by J.R. Farrar
 *  Modified for Shelly BLU Distance sensor via BTHome format
 *
 *  Expects MQTT topic format: BLE/{MAC_ADDRESS}
 *  Expects BTHome JSON payload with service_data.distance
 *
 * 1.0.0 - 11/08/25 - Initial Release for Shelly BLU Distance
 * 1.1.0 - 11/08/25 - Added optional inches display
 */

metadata {
    definition (name: "Shelly BLU Distance MQTT", 
                namespace: "jrfarrar", 
                author: "J.R. Farrar",
                importUrl: "") {
        capability "Initialize"
        capability "Refresh"
        capability "Configuration"
        capability "Sensor"
        
        attribute "distance", "number"
        attribute "distanceCm", "number"
        attribute "distanceInch", "number"
        attribute "battery", "number"
        attribute "rssi", "number"
        attribute "lastUpdate", "string"

preferences {
    section("Settings for connection from HE to Broker") {
        input name: "bluAddress", type: "text", title: "BLE Device MAC Address", required: false, description: "Optional: MAC address to filter (e.g., f8:44:77:1c:e3:08). Leave blank to accept all BLE devices."
        input name: "showInches", type: "bool", title: "Display distance in inches (in addition to cm)?", defaultValue: false, required: true
        input name: "ipAddr", type: "text", title: "IP Address of MQTT broker", required: true
        input name: "ipPort", type: "text", title: "Port # of MQTT broker", defaultValue: "1883", required: true
        input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false
	    input name: "password", type: "password", title: "MQTT Password:", description: "(blank if none)", required: false
        input name: "retryTime", type: "number", title: "Number of seconds between retries to connect if broker goes down", defaultValue: 300, required: true
        input name: "watchDogSched", type: "bool", title: "Check for connection to MQTT broker on a schedule?", defaultValue: false, required: true
        input name: "watchDogTime", type: "number", title: "This number of minutes to check for connection to MQTT broker", defaultValue: 15, range: "1..59", required: true
        input name: "logLevel",title: "IDE logging level",multiple: false,required: true,type: "enum", options: getLogLevels(), submitOnChange : false, defaultValue : "1"
        }
     }
  }
}

def setVersion(){
    state.name = "Shelly BLU Distance MQTT"
	state.version = "1.1.0 - Shelly BLU Distance MQTT Device Handler"   
}

void installed() {
    log.warn "installed..."
    setVersion()
}

// Parse incoming device messages to generate events
void parse(String description) {
    topicFull = interfaces.mqtt.parseMessage(description).topic
    debuglog "TOPIC FULL: " + topicFull
    
    def topic = topicFull.split('/')
    def message = interfaces.mqtt.parseMessage(description).payload
    debuglog "MESSAGE: " + message
    
    if (!message) {
        debuglog "Empty payload"
        return
    }
    
    // Expect topic format: BLE/{MAC_ADDRESS}
    if (topic[0] == "BLE" && topic.size() >= 2) {
        def deviceMac = topic[1]
        debuglog "BLE Device MAC: ${deviceMac}"
        
        // If bluAddress filter is set, only process matching device
        if (bluAddress && deviceMac != bluAddress) {
            debuglog "Skipping device ${deviceMac} - doesn't match filter ${bluAddress}"
            return
        }
        
        try {
            // Parse JSON payload from BLE device
            def jsonVal = parseJson(message)
            debuglog "Parsed JSON: " + jsonVal
            
            // Parse BTHome service_data structure
            if (jsonVal.service_data) {
                parseBTHomeData(jsonVal)
            } else {
                debuglog "No service_data found in message"
            }
            
        } catch(e) {
            log.warn "Error parsing JSON from BLE topic: ${e.message}"
            debuglog "Raw message: ${message}"
        }
    } else {
        debuglog "Unhandled topic format: ${topicFull}"
    }
}

// Parse BTHome sensor data
void parseBTHomeData(bleData) {
    debuglog "Parsing BTHome data: " + bleData
    
    def serviceData = bleData.service_data
    
    // Parse distance data
    if (serviceData.distance != null) {
        def distanceMm = serviceData.distance
        // Convert mm to cm - use BigDecimal to avoid scientific notation
        def distanceCm = new BigDecimal(distanceMm / 10.0).setScale(1, BigDecimal.ROUND_HALF_UP)
        
        // Log and send events
        if (showInches) {
            // Convert mm to inches (1 inch = 25.4mm)
            def distanceInch = new BigDecimal(distanceMm / 25.4).setScale(2, BigDecimal.ROUND_HALF_UP)
            infolog "Distance: ${distanceCm} cm (${distanceInch} in, ${distanceMm} mm)"
            sendEvent(name: "distanceInch", value: distanceInch, unit: "in")
        } else {
            infolog "Distance: ${distanceCm} cm (${distanceMm} mm)"
        }
        
        sendEvent(name: "distance", value: distanceMm, unit: "mm")
        sendEvent(name: "distanceCm", value: distanceCm, unit: "cm")
    }
    
    // Parse battery level
    if (serviceData.battery != null) {
        infolog "Battery: ${serviceData.battery}%"
        sendEvent(name: "battery", value: serviceData.battery, unit: "%")
    }
    
    // Parse RSSI (signal strength) from root level
    if (bleData.rssi != null) {
        debuglog "RSSI: ${bleData.rssi} dBm"
        sendEvent(name: "rssi", value: bleData.rssi, unit: "dBm")
    }
    
    // Update last update timestamp
    def now = new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone)
    sendEvent(name: "lastUpdate", value: now)
}

void refresh(){
    watchDog()
    setVersion()
    infolog "Refresh called - waiting for next MQTT update..."
}

void updated() {
    infolog "updated..."
    configure()
    unschedule()
    pauseExecution(1000)
    
    // Schedule the watchdog to run in case the broker restarts
    if (watchDogSched) {
        debuglog "Setting schedule to check for MQTT broker connection every ${watchDogTime} minutes"
        schedule("44 7/${watchDogTime} * ? * *", watchDog)
    }
}

void uninstalled() {
    infolog "Disconnecting from mqtt..."
    interfaces.mqtt.disconnect()
    unschedule()
}

void initialize() {
    infolog "initialize..."
    try {
        // Open connection
        def mqttInt = interfaces.mqtt
        mqttbroker = "tcp://" + ipAddr + ":" + ipPort
        mqttclientname = "Hubitat MQTT BLE Distance"
        mqttInt.connect(mqttbroker, mqttclientname, username, password)
        
        // Give it a chance to start
        pauseExecution(1000)
        infolog "Connection established..."
        
        // Subscribe to BLE topics
        // If bluAddress is specified, subscribe to that specific device
        // Otherwise subscribe to all BLE devices with wildcard
        if (bluAddress) {
            mqttInt.subscribe("BLE/${bluAddress}")
            infolog "Subscribed to topic: BLE/${bluAddress}"
        } else {
            mqttInt.subscribe("BLE/#")
            infolog "Subscribed to topic: BLE/# (all BLE devices)"
        }
        
    } catch(e) {
        log.warn "${device.label?device.label:device.name}: MQTT initialize error: ${e.message}"
    }
    
    // If logs are in "Need Help" turn down to "Running" after an hour
    logL = logLevel.toInteger()
    if (logL == 2) runIn(3600, logsOff)
}

void configure(){
    infolog "configure..."
    watchDog()
}

def watchDog() {
    debuglog "Checking MQTT status"    
    // If not connected, re-initialize
    if(!interfaces.mqtt.isConnected()) { 
        debuglog "MQTT Connected: (${interfaces.mqtt.isConnected()})"
        initialize()
    }
}

void mqttClientStatus(String message) {
	log.warn "${device.label?device.label:device.name}: **** Received status message: ${message} ****"
    if (message.contains("Connection lost")) {
        connectionLost()
    }
}

// If connection is dropped, try to reconnect every (retryTime) seconds until the connection is back
void connectionLost(){
    // Convert to milliseconds
    delayTime = retryTime * 1000
    while(!interfaces.mqtt.isConnected()) {
        infolog "Connection lost, attempting to reconnect..."
        initialize()
        pauseExecution(delayTime)
    }
}
    
// Logging below here
def logsOff(){
    log.warn "Debug logging disabled"
    device.updateSetting("logLevel", [value: "1", type: "enum"])
}

def debuglog(statement) {   
	def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 2) {
		log.debug("${device.label?device.label:device.name}: " + statement)
	}
}

def infolog(statement) {       
	def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 1) {
		log.info("${device.label?device.label:device.name}: " + statement)
	}
}

def getLogLevels(){
    return [["0":"None"],["1":"Running"],["2":"NeedHelp"]]
}
