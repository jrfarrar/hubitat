/**
 * Shelly BLU Distance MQTT Device Handler
 *
 * Modified from BI MQTT Motion by J.R. Farrar
 * Modified for Shelly BLU Distance sensor via BTHome format
 *
 * Expects MQTT topic format: BLE/{MAC_ADDRESS}
 * Expects BTHome JSON payload with service_data.distance
 *
 * 1.0.0 - 11/08/25 - Initial Release for Shelly BLU Distance
 * 1.1.0 - 11/08/25 - Added optional inches display
 * 1.2.0 - 11/08/25 - Added threshold-based switch capability
 * 1.3.0 - 11/24/25 - Added time delay requirement for threshold activation
 * 1.4.0 - 11/24/25 - Added Logic Inversion (Above/Below) and Quieted RSSI/LastUpdate chatter
 * 1.4.1 - 11/24/25 - Minor refinements: timer update throttling, improved descriptions, RSSI init
 * 1.4.2 - 11/24/25 - Added suppression of INFO logs for unchanged distance/battery values
 * 1.4.3 - 11/30/25 - Fixed cron expression error for watchDogTime values > 59 minutes
 * 1.4.4 - 11/30/25 - Added battery hysteresis to smooth out sensor noise/wild swings
 */

metadata {
    definition (name: "Shelly BLU Distance MQTT", 
                namespace: "jrfarrar", 
                author: "J.R. Farrar",
                importUrl: "") {
        capability "Initialize"
        capability "Refresh"
        capability "Configuration"
        capability "Sensor"
        capability "Switch"
        
        attribute "distance", "number"
        attribute "distanceCm", "number"
        attribute "distanceInch", "number"
        attribute "battery", "number"
        attribute "rssi", "number"
        attribute "lastUpdate", "string"
        attribute "thresholdTimer", "string"
        
        command "on"
        command "off"
        command "resetThresholdTimer"
    }

    preferences {
        section("Settings for connection from HE to Broker") {
            input name: "bluAddress", type: "text", title: "BLE Device MAC Address", required: false, description: "Optional: MAC address to filter (e.g., f8:44:77:1c:e3:08). Leave blank to accept all BLE devices."
            input name: "showInches", type: "bool", title: "Display distance in inches (in addition to cm)?", defaultValue: false, required: true
            input name: "ipAddr", type: "text", title: "IP Address of MQTT broker", required: true
            input name: "ipPort", type: "text", title: "Port # of MQTT broker", defaultValue: "1883", required: true
            input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false
            input name: "password", type: "password", title: "MQTT Password:", description: "(blank if none)", required: false
            input name: "retryTime", type: "number", title: "Number of seconds between retries to connect if broker goes down", defaultValue: 300, required: true
            input name: "watchDogSched", type: "bool", title: "Check for connection to MQTT broker on a schedule?", defaultValue: false, required: true
            input name: "watchDogTime", type: "number", title: "Check MQTT broker connection interval", defaultValue: 15, range: "1..240", required: true, description: "1-59 = every X minutes, 60-240 = converted to hourly (e.g., 120 = every 2 hours)"
            input name: "logLevel",title: "IDE logging level",multiple: false,required: true,type: "enum", options: getLogLevels(), submitOnChange : false, defaultValue : "1"
        }
        section("Threshold Switch Settings") {
            input name: "enableThreshold", type: "bool", title: "Enable switch based on distance threshold?", defaultValue: false, required: true
            input name: "triggerType", type: "enum", title: "Trigger Condition", options: ["Distance > Threshold", "Distance < Threshold"], defaultValue: "Distance > Threshold", required: true, description: "Choose when the switch turns ON"
            input name: "thresholdValue", type: "number", title: "Threshold value", defaultValue: 50, required: false, description: "Switch turns ON when trigger condition is met"
            input name: "thresholdUnit", type: "enum", title: "Threshold unit", options: ["mm", "cm", "in"], defaultValue: "cm", required: false
            input name: "enableTimeDelay", type: "bool", title: "Require time delay before turning ON?", defaultValue: false, required: true, description: "When enabled, condition must be met for specified time"
            input name: "timeDelayMinutes", type: "number", title: "Minutes condition met before ON", defaultValue: 5, required: false
        }
        section("Sensor Filtering") {
            input name: "batteryHysteresis", type: "number", title: "Battery change threshold (%)", defaultValue: 10, range: "1..25", required: true, description: "Only report battery when it changes by more than this amount (reduces noise)"
            input name: "rssiHysteresis", type: "number", title: "RSSI change threshold (dBm)", defaultValue: 5, range: "1..20", required: true, description: "Only report RSSI when it changes by more than this amount"
        }
    }
}

def setVersion(){
    state.name = "Shelly BLU Distance MQTT"
    state.version = "1.4.4 - Shelly BLU Distance MQTT Device Handler"   
}

void installed() {
    log.warn "installed..."
    setVersion()
    sendEvent(name: "switch", value: "off")
    sendEvent(name: "thresholdTimer", value: "inactive")
    sendEvent(name: "rssi", value: -100, unit: "dBm")
    state.thresholdExceededTime = null
    state.lastRssi = -100
    state.lastBattery = null
    state.lastTimerUpdate = 0
}

// Parse incoming device messages to generate events
void parse(String description) {
    topicFull = interfaces.mqtt.parseMessage(description).topic
    debuglog "TOPIC FULL: " + topicFull
    
    def topic = topicFull.split('/')
    def message = interfaces.mqtt.parseMessage(description).payload
    debuglog "MESSAGE: " + message
    
    if (!message) {
        debuglog "Empty payload"
        return
    }
    
    // Expect topic format: BLE/{MAC_ADDRESS}
    if (topic[0] == "BLE" && topic.size() >= 2) {
        def deviceMac = topic[1]
        debuglog "BLE Device MAC: ${deviceMac}"
        
        // If bluAddress filter is set, only process matching device
        if (bluAddress && deviceMac != bluAddress) {
            debuglog "Skipping device ${deviceMac} - doesn't match filter ${bluAddress}"
            return
        }
        
        try {
            // Parse JSON payload from BLE device
            def jsonVal = parseJson(message)
            debuglog "Parsed JSON: " + jsonVal
            
            // Parse BTHome service_data structure
            if (jsonVal.service_data) {
                parseBTHomeData(jsonVal)
            } else {
                debuglog "No service_data found in message"
            }
            
        } catch(e) {
            log.warn "Error parsing JSON from BLE topic: ${e.message}"
            debuglog "Raw message: ${message}"
        }
    } else {
        debuglog "Unhandled topic format: ${topicFull}"
    }
}

// Parse BTHome sensor data
void parseBTHomeData(bleData) {
    debuglog "Parsing BTHome data: " + bleData
    
    def serviceData = bleData.service_data
    boolean dataChanged = false
    
    // Parse distance data
    if (serviceData.distance != null) {
        def distanceMm = serviceData.distance
        // Convert mm to cm - use BigDecimal to avoid scientific notation
        def distanceCm = new BigDecimal(distanceMm / 10.0).setScale(1, BigDecimal.ROUND_HALF_UP)
        
        // Check if value changed from last time (to suppress repetitive INFO logs)
        def currentDist = device.currentValue("distance")
        boolean distValChanged = (currentDist == null || currentDist.toInteger() != distanceMm.toInteger())

        // Log and send events
        if (showInches) {
            // Convert mm to inches (1 inch = 25.4mm)
            def distanceInch = new BigDecimal(distanceMm / 25.4).setScale(2, BigDecimal.ROUND_HALF_UP)
            if (distValChanged) infolog "Distance changed: ${distanceCm} cm (${distanceInch} in, ${distanceMm} mm)"
            sendEvent(name: "distanceInch", value: distanceInch, unit: "in")
        } else {
            if (distValChanged) infolog "Distance changed: ${distanceCm} cm (${distanceMm} mm)"
        }
        
        sendEvent(name: "distance", value: distanceMm, unit: "mm")
        sendEvent(name: "distanceCm", value: distanceCm, unit: "cm")
        dataChanged = true
        
        // Check threshold and update switch state
        if (enableThreshold) {
            evaluateThreshold(distanceMm, distanceCm)
        }
    }
    
    // Parse battery level with hysteresis to reduce noise from sensor fluctuations
    if (serviceData.battery != null) {
        def currentBattery = serviceData.battery.toInteger()
        def lastBattery = state.lastBattery != null ? state.lastBattery.toInteger() : -100
        def battThreshold = batteryHysteresis != null ? batteryHysteresis.toInteger() : 10
        
        // Only update if battery changed by more than threshold to reduce noise
        if (Math.abs(currentBattery - lastBattery) > battThreshold) {
            if (lastBattery == -100) {
                infolog "Battery initial reading: ${currentBattery}%"
            } else {
                infolog "Battery changed: ${currentBattery}% (was ${lastBattery}%)"
            }
            sendEvent(name: "battery", value: currentBattery, unit: "%")
            state.lastBattery = currentBattery
            dataChanged = true
        } else {
            debuglog "Battery ignored (within ${battThreshold}% hysteresis): ${currentBattery}% (last reported: ${lastBattery}%)"
        }
    }
    
    // Parse RSSI (signal strength) from root level with hysteresis
    // Only update if value changes by more than threshold to reduce database noise
    if (bleData.rssi != null) {
        def currentRssi = bleData.rssi.toInteger()
        def lastRssi = state.lastRssi != null ? state.lastRssi.toInteger() : -100
        def rssiThreshold = rssiHysteresis != null ? rssiHysteresis.toInteger() : 5
        
        if (Math.abs(currentRssi - lastRssi) > rssiThreshold) {
            debuglog "RSSI changed significantly (${lastRssi} -> ${currentRssi} dBm) - updating"
            sendEvent(name: "rssi", value: currentRssi, unit: "dBm")
            state.lastRssi = currentRssi
            // Note: We do NOT set dataChanged = true here. 
            // We don't want to update LastUpdate timestamp just because signal fluctuated.
        } else {
            debuglog "RSSI ignored (within ${rssiThreshold}dBm hysteresis): ${currentRssi} dBm"
        }
    }
    
    // Update last update timestamp ONLY if actual data (distance/battery) changed
    if (dataChanged) {
        def now = new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone)
        sendEvent(name: "lastUpdate", value: now)
    }
}

void refresh(){
    watchDog()
    setVersion()
    infolog "Refresh called - waiting for next MQTT update..."
}

void evaluateThreshold(distanceMm, distanceCm) {
    if (!thresholdValue) {
        debuglog "No threshold value set"
        return
    }
    
    // Convert distance to the threshold unit for comparison
    def compareValue
    switch(thresholdUnit) {
        case "mm":
            compareValue = distanceMm
            break
        case "cm":
            compareValue = distanceCm
            break
        case "in":
            compareValue = new BigDecimal(distanceMm / 25.4).setScale(2, BigDecimal.ROUND_HALF_UP)
            break
        default:
            compareValue = distanceCm
    }
    
    def currentSwitch = device.currentValue("switch") ?: "off"
    
    // Check trigger condition based on preference
    boolean thresholdMet = false
    
    if (triggerType == "Distance < Threshold") {
        // ON when Short (e.g., Car Present)
        if (compareValue < thresholdValue) thresholdMet = true
    } else {
        // ON when Long (Default - e.g., Salt Empty)
        if (compareValue > thresholdValue) thresholdMet = true
    }
    
    // Logic Execution
    if (thresholdMet) {
        // Condition is Met
        if (enableTimeDelay && timeDelayMinutes != null && timeDelayMinutes > 0) {
            // Time delay is enabled - check if we need to start or continue timer
            if (state.thresholdExceededTime == null) {
                // First time exceeding threshold - start the timer
                state.thresholdExceededTime = now()
                state.lastTimerUpdate = now()
                def timeStr = new Date().format("HH:mm:ss", location.timeZone)
                sendEvent(name: "thresholdTimer", value: "waiting (started ${timeStr})")
                infolog "Trigger condition met (${compareValue}${thresholdUnit}) - timer started, waiting ${timeDelayMinutes} minute(s)"
            } else {
                // Timer already running - check if enough time has elapsed
                def elapsedMillis = now() - state.thresholdExceededTime
                def elapsedMinutes = String.format("%.1f", elapsedMillis / 60000.0)
                
                debuglog "Timer running: ${elapsedMinutes} of ${timeDelayMinutes} minutes elapsed"
                
                if (elapsedMillis >= (timeDelayMinutes * 60000)) {
                    // Enough time has passed - turn switch ON
                    if (currentSwitch != "on") {
                        infolog "Condition met for ${elapsedMinutes} minute(s) - turning switch ON"
                        sendEvent(name: "switch", value: "on")
                        sendEvent(name: "thresholdTimer", value: "triggered")
                    }
                } else {
                    // Still waiting - update status only every 30 seconds to reduce chatter
                    def timeSinceLastUpdate = now() - (state.lastTimerUpdate ?: 0)
                    if (timeSinceLastUpdate >= 30000) {
                        def timeStr = new Date(state.thresholdExceededTime).format("HH:mm:ss", location.timeZone)
                        sendEvent(name: "thresholdTimer", value: "waiting ${elapsedMinutes}/${timeDelayMinutes} min (started ${timeStr})")
                        state.lastTimerUpdate = now()
                    }
                }
            }
        } else {
            // Time delay disabled - turn ON immediately
            if (currentSwitch != "on") {
                infolog "Trigger condition met (${compareValue}${thresholdUnit}) - turning switch ON"
                sendEvent(name: "switch", value: "on")
                sendEvent(name: "thresholdTimer", value: "inactive")
            }
        }
    } else {
        // Condition NOT met - turn OFF and reset timer
        if (state.thresholdExceededTime != null) {
            infolog "Condition no longer met - resetting timer"
            state.thresholdExceededTime = null
            state.lastTimerUpdate = 0
            sendEvent(name: "thresholdTimer", value: "reset")
        }
        
        if (currentSwitch != "off") {
            infolog "Condition no longer met (${compareValue}${thresholdUnit}) - turning switch OFF"
            sendEvent(name: "switch", value: "off")
            sendEvent(name: "thresholdTimer", value: "inactive")
        }
    }
}

// These commands are for Switch capability - they update state but warn that it's normally threshold-controlled
void on() {
    infolog "Manual ON command received"
    sendEvent(name: "switch", value: "on")
    if (enableThreshold) {
        log.warn "Note: Switch is configured to be controlled by distance threshold"
    }
}

void off() {
    infolog "Manual OFF command received"
    sendEvent(name: "switch", value: "off")
    if (enableThreshold) {
        log.warn "Note: Switch is configured to be controlled by distance threshold"
    }
}

void resetThresholdTimer() {
    infolog "Manual reset of threshold timer"
    state.thresholdExceededTime = null
    state.lastTimerUpdate = 0
    sendEvent(name: "thresholdTimer", value: "reset")
}

void updated() {
    infolog "updated..."
    
    // Initialize switch state if threshold is enabled
    if (enableThreshold) {
        if (device.currentValue("switch") == null) {
            sendEvent(name: "switch", value: "off")
            infolog "Initialized switch state to OFF"
        }
    }
    
    // Reset timer if time delay settings changed
    if (enableTimeDelay) {
        state.thresholdExceededTime = null
        state.lastTimerUpdate = 0
        sendEvent(name: "thresholdTimer", value: "inactive")
        debuglog "Timer reset due to settings update"
    }
    
    configure()
    unschedule()
    pauseExecution(1000)
    
    // Schedule the watchdog to run in case the broker restarts
    if (watchDogSched) {
        if (watchDogTime <= 59) {
            // Minute-based scheduling for intervals under 60 minutes
            debuglog "Setting schedule to check MQTT broker connection every ${watchDogTime} minute(s)"
            schedule("44 0/${watchDogTime} * ? * *", watchDog)
        } else {
            // Hour-based scheduling for intervals 60 minutes or greater
            def hours = Math.round(watchDogTime / 60.0).toInteger()
            if (hours < 1) hours = 1
            if (hours > 23) hours = 23
            debuglog "Setting schedule to check MQTT broker connection every ${hours} hour(s)"
            schedule("44 7 0/${hours} ? * *", watchDog)
        }
    }
}

void uninstalled() {
    infolog "Disconnecting from mqtt..."
    interfaces.mqtt.disconnect()
    unschedule()
}

void initialize() {
    infolog "initialize..."
    
    // Initialize switch state if threshold is enabled
    if (enableThreshold && device.currentValue("switch") == null) {
        sendEvent(name: "switch", value: "off")
        infolog "Initialized switch state to OFF"
    }
    
    // Initialize timer attribute
    if (device.currentValue("thresholdTimer") == null) {
        sendEvent(name: "thresholdTimer", value: "inactive")
    }
    
    // Initialize RSSI attribute
    if (device.currentValue("rssi") == null) {
        sendEvent(name: "rssi", value: -100, unit: "dBm")
    }
    
    // Initialize state variables for hysteresis
    if (state.lastBattery == null) state.lastBattery = -100
    if (state.lastRssi == null) state.lastRssi = -100
    
    try {
        // Open connection
        def mqttInt = interfaces.mqtt
        mqttbroker = "tcp://" + ipAddr + ":" + ipPort
        mqttclientname = "Hubitat MQTT BLE Distance"
        mqttInt.connect(mqttbroker, mqttclientname, username, password)
        
        // Give it a chance to start
        pauseExecution(1000)
        infolog "Connection established..."
        
        // Subscribe to BLE topics
        // If bluAddress is specified, subscribe to that specific device
        // Otherwise subscribe to all BLE devices with wildcard
        if (bluAddress) {
            mqttInt.subscribe("BLE/${bluAddress}")
            infolog "Subscribed to topic: BLE/${bluAddress}"
        } else {
            mqttInt.subscribe("BLE/#")
            infolog "Subscribed to topic: BLE/# (all BLE devices)"
        }
        
    } catch(e) {
        log.warn "${device.label?device.label:device.name}: MQTT initialize error: ${e.message}"
    }
    
    // If logs are in "Need Help" turn down to "Running" after an hour
    logL = logLevel.toInteger()
    if (logL == 2) runIn(3600, logsOff)
}

void configure(){
    infolog "configure..."
    watchDog()
}

def watchDog() {
    debuglog "Checking MQTT status"     
    // If not connected, re-initialize
    if(!interfaces.mqtt.isConnected()) { 
        debuglog "MQTT Connected: (${interfaces.mqtt.isConnected()})"
        initialize()
    }
}

void mqttClientStatus(String message) {
    log.warn "${device.label?device.label:device.name}: **** Received status message: ${message} ****"
    if (message.contains("Connection lost")) {
        connectionLost()
    }
}

// If connection is dropped, try to reconnect every (retryTime) seconds until the connection is back
void connectionLost(){
    // Convert to milliseconds
    delayTime = retryTime * 1000
    while(!interfaces.mqtt.isConnected()) {
        infolog "Connection lost, attempting to reconnect..."
        initialize()
        pauseExecution(delayTime)
    }
}
    
// Logging below here
def logsOff(){
    log.warn "Debug logging disabled"
    device.updateSetting("logLevel", [value: "1", type: "enum"])
}

def debuglog(statement) {   
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 2) {
        log.debug("${device.label?device.label:device.name}: " + statement)
    }
}

def infolog(statement) {        
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 1) {
        log.info("${device.label?device.label:device.name}: " + statement)
    }
}

def getLogLevels(){
    return [["0":"None"],["1":"Running"],["2":"NeedHelp"]]
}
