/**
 * Shelly Gateway Status MQTT Device Handler
 *
 * Modified from BI MQTT Motion by J.R. Farrar
 * Tracks Shelly Gateway online/offline status
 *
 * 1.0.0 - 11/08/25 - Initial Release for Gateway Status Tracking
 * 1.1.0 - 11/24/25 - Added throttling for lastSeen updates to reduce DB noise (max 1/min)
 */

metadata {
    definition (name: "Shelly Gateway Status", 
                namespace: "jrfarrar", 
                author: "J.R. Farrar",
                importUrl: "") {
        capability "Initialize"
        capability "Refresh"
        capability "Configuration"
        capability "Sensor"
        capability "PresenceSensor"
        
        attribute "online", "enum", ["true", "false"]
        attribute "presence", "enum", ["present", "not present"]
        attribute "lastSeen", "string"

    preferences {
        section("Settings for connection from HE to Broker") {
            input name: "gatewayName", type: "text", title: "Gateway Name/ID (e.g., shellyblugw-08d1f90435e4)", required: true, description: "The gateway device ID"
            input name: "ipAddr", type: "text", title: "IP Address of MQTT broker", required: true
            input name: "ipPort", type: "text", title: "Port # of MQTT broker", defaultValue: "1883", required: true
            input name: "username", type: "text", title: "MQTT Username:", description: "(blank if none)", required: false
            input name: "password", type: "password", title: "MQTT Password:", description: "(blank if none)", required: false
            input name: "retryTime", type: "number", title: "Number of seconds between retries to connect if broker goes down", defaultValue: 300, required: true
            input name: "watchDogSched", type: "bool", title: "Check for connection to MQTT broker on a schedule?", defaultValue: false, required: true
            input name: "watchDogTime", type: "number", title: "This number of minutes to check for connection to MQTT broker", defaultValue: 15, range: "1..59", required: true
            input name: "offlineTimeout", type: "number", title: "Minutes without update before marking offline", defaultValue: 10, range: "1..60", required: true
            input name: "logLevel",title: "IDE logging level",multiple: false,required: true,type: "enum", options: getLogLevels(), submitOnChange : false, defaultValue : "1"
        }
     }
  }
}

def setVersion(){
    state.name = "Shelly Gateway Status MQTT"
    state.version = "1.1.0 - Shelly Gateway Status MQTT Device Handler"   
}

void installed() {
    log.warn "installed..."
    setVersion()
    sendEvent(name: "online", value: "false")
    sendEvent(name: "presence", value: "not present")
    state.lastSeenMillis = 0
}

// Parse incoming device messages to generate events
void parse(String description) {
    topicFull = interfaces.mqtt.parseMessage(description).topic
    debuglog "TOPIC FULL: " + topicFull
    
    def topic = topicFull.split('/')
    def topicType = topic[-1] // Get last part of topic
    
    def message = interfaces.mqtt.parseMessage(description).payload
    debuglog "MESSAGE: " + message
    
    if (!message) {
        debuglog "Empty payload"
        return
    }
    
    // Update last seen timestamp (Throttled inside the function)
    updateLastSeen()
    
    // Handle the online topic (true/false)
    if (topicType == "online") {
        setOnlineStatus(message)
        return
    }
    
    // Handle events/rpc topic (system heartbeat messages)
    if (topicType == "rpc") {
        try {
            def jsonVal = parseJson(message)
            debuglog "Parsed JSON: " + jsonVal
            
            // If we receive any event from the gateway, it's online
            if (jsonVal.method == "NotifyStatus" || jsonVal.src) {
                debuglog "Received heartbeat from gateway"
                setOnlineStatus("true")
            }
            
        } catch(e) {
            log.warn "Error parsing JSON: ${e.message}"
        }
    }
    
    // Handle status topic
    if (topicType == "status") {
        try {
            def jsonVal = parseJson(message)
            debuglog "Parsed status JSON: " + jsonVal
            // Gateway is online if it's publishing status
            setOnlineStatus("true")
        } catch(e) {
            debuglog "Status message not JSON or error: ${e.message}"
        }
    }
}

void setOnlineStatus(status) {
    def isOnline = (status == "true" || status == true)
    def onlineValue = isOnline ? "true" : "false"
    def presenceValue = isOnline ? "present" : "not present"
    
    // Only send event and log if status actually changes
    if (device.currentValue("online") != onlineValue) {
        infolog "Gateway status changed to: ${onlineValue}"
        sendEvent(name: "online", value: onlineValue)
        sendEvent(name: "presence", value: presenceValue)
    } else {
        debuglog "Gateway reported ${onlineValue} (no change)"
    }
}

void updateLastSeen() {
    // THROTTLING LOGIC:
    // Only update the DB and reset the timer if it's been > 60 seconds
    // or if this is the very first run.
    
    def now = now()
    def lastUpdate = state.lastSeenMillis ?: 0
    
    if (now - lastUpdate > 60000) {
        def timestamp = new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone)
        sendEvent(name: "lastSeen", value: timestamp)
        state.lastSeenMillis = now
        
        // Reset the offline check timer
        // We only need to do this when we update the timestamp
        unschedule(checkOffline)
        runIn(offlineTimeout * 60, checkOffline)
        debuglog "Updated lastSeen and reset offline timer"
    }
}

void checkOffline() {
    // Double check logic: ensure we really haven't seen it in a while
    // (in case a reboot cleared the schedule but state persisted)
    def timeoutMillis = offlineTimeout * 60 * 1000
    def lastSeen = state.lastSeenMillis ?: 0
    def currentTime = now()
    
    if (currentTime - lastSeen > timeoutMillis) {
        log.warn "No updates received for ${offlineTimeout} minutes - marking gateway offline"
        setOnlineStatus("false")
    } else {
        // This is a safety catch. If we are here, but time hasn't elapsed, 
        // it means we got an update recently. Reschedule the check.
        def timeRemaining = ((lastSeen + timeoutMillis) - currentTime) / 1000
        if (timeRemaining > 0) runIn(timeRemaining.toInteger(), checkOffline)
    }
}

void refresh(){
    watchDog()
    setVersion()
    infolog "Refresh called - waiting for next MQTT update..."
}

void updated() {
    infolog "updated..."
    configure()
    unschedule()
    pauseExecution(1000)
    
    // Schedule the watchdog to run in case the broker restarts
    if (watchDogSched) {
        debuglog "Setting schedule to check for MQTT broker connection every ${watchDogTime} minutes"
        schedule("44 7/${watchDogTime} * ? * *", watchDog)
    }
}

void uninstalled() {
    infolog "Disconnecting from mqtt..."
    interfaces.mqtt.disconnect()
    unschedule()
}

void initialize() {
    infolog "initialize..."
    try {
        // Open connection
        def mqttInt = interfaces.mqtt
        mqttbroker = "tcp://" + ipAddr + ":" + ipPort
        mqttclientname = "Hubitat MQTT Gateway Status"
        mqttInt.connect(mqttbroker, mqttclientname, username, password)
        
        // Give it a chance to start
        pauseExecution(1000)
        infolog "Connection established..."
        
        // Subscribe to gateway status topics
        mqttInt.subscribe("${gatewayName}/online")
        mqttInt.subscribe("${gatewayName}/events/rpc")
        mqttInt.subscribe("${gatewayName}/status")
        
        infolog "Subscribed to topics: ${gatewayName}/online, ${gatewayName}/events/rpc, ${gatewayName}/status"
        
    } catch(e) {
        log.warn "${device.label?device.label:device.name}: MQTT initialize error: ${e.message}"
    }
    
    // If logs are in "Need Help" turn down to "Running" after an hour
    logL = logLevel.toInteger()
    if (logL == 2) runIn(3600, logsOff)
}

void configure(){
    infolog "configure..."
    watchDog()
}

def watchDog() {
    debuglog "Checking MQTT status"     
    // If not connected, re-initialize
    if(!interfaces.mqtt.isConnected()) { 
        debuglog "MQTT Connected: (${interfaces.mqtt.isConnected()})"
        initialize()
    }
}

void mqttClientStatus(String message) {
    log.warn "${device.label?device.label:device.name}: **** Received status message: ${message} ****"
    if (message.contains("Connection lost")) {
        connectionLost()
    }
}

// If connection is dropped, try to reconnect every (retryTime) seconds until the connection is back
void connectionLost(){
    // Convert to milliseconds
    delayTime = retryTime * 1000
    while(!interfaces.mqtt.isConnected()) {
        infolog "Connection lost, attempting to reconnect..."
        initialize()
        pauseExecution(delayTime)
    }
}
    
// Logging below here
def logsOff(){
    log.warn "Debug logging disabled"
    device.updateSetting("logLevel", [value: "1", type: "enum"])
}

def debuglog(statement) {   
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 2) {
        log.debug("${device.label?device.label:device.name}: " + statement)
    }
}

def infolog(statement) {        
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return} // bail
    else if (logL >= 1) {
        log.info("${device.label?device.label:device.name}: " + statement)
    }
}

def getLogLevels(){
    return [["0":"None"],["1":"Running"],["2":"NeedHelp"]]
}
