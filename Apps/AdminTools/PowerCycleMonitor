/*
 *	Power Cycle Monitor
 *
 *	Author: J.R. Farrar
 * 
 *  Monitors a device's power cycling pattern and triggers a switch
 *  if the device continues to cycle on/off (indicating it was left on)
 *
 *  V 1.0 - 2025-11-08 - Initial Release
 *  V 1.1 - 2025-11-12 - Added cycle timing tracking (average ON/OFF durations)
 * 
 */

definition(
  name: "Power Cycle Monitor Child",
  namespace: "jrfarrar",
  author: "J.R. Farrar",
  description: "Monitor power cycling and trigger switch if device is left on",
  parent: "jrfarrar:Admin tools",    
  iconUrl: "",
  iconX2Url: "",
  iconX3Url: "",
  importUrl: ""
)


preferences {
    page(name: "pageConfig")
}

def pageConfig() {
    dynamicPage(name: "", title: "", install: true, uninstall: true, refreshInterval:0) { 
        
        section(getFormat("header-green", "DEVICES")) {
            paragraph "- Monitor a power meter for cycling patterns. If device cycles on/off repeatedly, it indicates it was 'left on'."
            input (name: "pwrMeter", type: "capability.powerMeter", title: "Power Meter to Monitor", submitOnChange: true, required: true)
            input (name: "alertSwitch", type: "capability.switch", title: "Switch to turn ON when cycling detected", submitOnChange: true, required: true, multiple: false)
        }
        
        section(getFormat("header-green", "CYCLE DETECTION SETTINGS")) {
            paragraph "Device is considered 'left on' if it cycles multiple times within a time window"
            input (name: "watts", type: "number", title: "Watt threshold (power above = ON, below = OFF)", required: true, defaultValue: 100)
            input (name: "cycleCount", type: "number", title: "Number of cycles to detect", required: true, defaultValue: 3, description: "How many on/off cycles indicate 'left on'")
            input (name: "timeWindow", type: "number", title: "Time window in minutes", required: true, defaultValue: 30, description: "Cycles must occur within this time window")
            input (name: "offTimeout", type: "number", title: "Minutes off before considering 'turned off'", required: true, defaultValue: 60, description: "If no cycles for this long, device is considered off")
        }
        
        section(getFormat("header-green", "RESTRICTIONS")) {
            paragraph "- Optional: Restrict when this monitor is active"
            input (name: "restrictSwitch", type: "capability.switch", title: "Only run when this switch is ON", submitOnChange: true, required: false, multiple: false)
            input (name: "noRunModes", type: "mode", title: "Do NOT run in these modes", submitOnChange: true, required: false, multiple: true)
        }
        
        section(getFormat("header-green", "LOGGING")){                       
            input(name: "logLevel", title: "IDE logging level", multiple: false, required: true, type: "enum", options: getLogLevels(), submitOnChange: false, defaultValue: "1")
        }
        
        section(getFormat("header-green", "APP NAME")){
            input (name: "thisName", type: "text", title: "App Name", submitOnChange: true)
            if(thisName) {
                app.updateLabel("$thisName")
            } else {
                app.updateSetting("thisName", "Power Cycle Monitor")
            }
        }
    }  
} 

def installed() {
    infolog "installed"
    initialize()
}

def updated() {
    infolog "updated"
    unsubscribe()
    unschedule()
    initialize()
}

def initialize() {
    infolog "initialize"
    unschedule() 
    unsubscribe()
    subscribeToEvents()
    state.deviceOn = false
    state.cycleHistory = []
    state.onDurations = []
    state.offDurations = []
    // Don't initialize lastStateChangeTime - let it be null so first duration calc is skipped
    state.leftOnDetected = false
    state.lastActivity = now()
    updateAppLabel()
}

def uninstalled() {
    unschedule()
    unsubscribe()
    infolog "uninstalled"
}

def subscribeToEvents() {
    if (pwrMeter) {
        subscribe(pwrMeter, "power", powerHandler)
        infolog "Subscribed to power meter: ${pwrMeter}"
    }
}

def powerHandler(evt) {
    // Check if we can run based on restrictions
    if (!canWeRun()) {
        debuglog "Restrictions prevent running"
        return
    }
    
    dblePower = Double.parseDouble(evt.value)
    rndPower = Math.round(dblePower)
    debuglog "Power: ${rndPower}W from ${evt.device}"
    
    // Sanity check - ignore erroneous readings
    if (rndPower > 10000) {
        log.warn "Ignoring erroneous power reading: ${rndPower}W"
        return
    }
    
    // Determine if device is currently ON or OFF
    def isOn = (rndPower > watts)
    def currentTime = now()
    
    // Detect state change (cycle)
    if (isOn && !state.deviceOn) {
        // Device just turned ON
        // Calculate OFF duration if we have a last state change time
        if (state.lastStateChangeTime) {
            def offDuration = (currentTime - state.lastStateChangeTime) / 1000.0 / 60.0 // minutes
            
            // Initialize array if it doesn't exist (for upgrades from old version)
            if (!state.offDurations) {
                state.offDurations = []
            }
            
            state.offDurations.add(offDuration)
            
            // Keep only durations within the time window
            def windowMillis = timeWindow * 60 * 1000
            state.offDurations = state.offDurations.findAll { duration ->
                // This is a simplification - we're keeping recent durations
                true
            }
            if (state.offDurations.size() > cycleCount * 2) {
                state.offDurations = state.offDurations.drop(1) // Keep list reasonable
            }
            
            debuglog "OFF duration: ${String.format('%.2f', offDuration)} minutes"
        }
        
        state.deviceOn = true
        state.lastStateChangeTime = currentTime
        state.lastActivity = currentTime
        recordCycle()
        infolog "Device turned ON (${rndPower}W)"
        
        // Schedule check for timeout (device truly off)
        unschedule(checkDeviceOff)
        runIn(60 * offTimeout.toInteger(), checkDeviceOff)
        
    } else if (!isOn && state.deviceOn) {
        // Device just turned OFF
        // Calculate ON duration
        if (state.lastStateChangeTime) {
            def onDuration = (currentTime - state.lastStateChangeTime) / 1000.0 / 60.0 // minutes
            
            // Initialize array if it doesn't exist (for upgrades from old version)
            if (!state.onDurations) {
                state.onDurations = []
            }
            
            state.onDurations.add(onDuration)
            
            // Keep only durations within the time window
            if (state.onDurations.size() > cycleCount * 2) {
                state.onDurations = state.onDurations.drop(1) // Keep list reasonable
            }
            
            debuglog "ON duration: ${String.format('%.2f', onDuration)} minutes"
        }
        
        state.deviceOn = false
        state.lastStateChangeTime = currentTime
        infolog "Device turned OFF (${rndPower}W)"
    }
    
    // Check if we've detected enough cycles to indicate "left on"
    evaluateCyclePattern()
}

def recordCycle() {
    // Add current time to cycle history
    def currentTime = now()
    
    if (!state.cycleHistory) {
        state.cycleHistory = []
    }
    
    state.cycleHistory.add(currentTime)
    
    // Remove old cycles outside the time window
    def windowMillis = timeWindow * 60 * 1000
    state.cycleHistory = state.cycleHistory.findAll { cycleTime ->
        (currentTime - cycleTime) < windowMillis
    }
    
    debuglog "Cycle recorded. Total cycles in last ${timeWindow} minutes: ${state.cycleHistory.size()}"
}

def evaluateCyclePattern() {
    def cyclesInWindow = state.cycleHistory?.size() ?: 0
    
    if (cyclesInWindow >= cycleCount && !state.leftOnDetected) {
        // Device has cycled enough times - it's "left on"
        state.leftOnDetected = true
        state.onStartTime = now()  // Record when device officially turned ON
        state.alertTime = new Date().format("yyyy-MM-dd HH:mm:ss")
        
        // Calculate and log average ON/OFF times
        def avgOn = calculateAverage(state.onDurations)
        def avgOff = calculateAverage(state.offDurations)
        
        infolog "ALERT: Device has cycled ${cyclesInWindow} times in ${timeWindow} minutes! Device appears to be LEFT ON."
        infolog "Cycle Stats - Avg ON time: ${avgOn}, Avg OFF time: ${avgOff}"
        
        if (alertSwitch.latestValue("switch") != "on") {
            alertSwitch.on()
        }
        
        updateAppLabel()
    }
}

def calculateAverage(List durations) {
    if (!durations || durations.size() == 0) {
        return "N/A"
    }
    
    def sum = durations.sum()
    def avg = sum / durations.size()
    
    // Convert to double to avoid BigDecimal rounding issues
    def avgDouble = avg.toDouble()
    
    // Format nicely
    if (avgDouble < 1.0) {
        return "${Math.round(avgDouble * 60)} seconds"
    } else if (avgDouble < 60) {
        return "${String.format('%.1f', avgDouble)} minutes"
    } else {
        def hours = (avgDouble / 60).toInteger()
        def minutes = Math.round(avgDouble % 60)
        return "${hours}h ${minutes}m"
    }
}

def checkDeviceOff() {
    // This runs if no activity for offTimeout minutes
    def minutesSinceActivity = new BigDecimal((now() - state.lastActivity) / 1000.0 / 60.0).setScale(1, BigDecimal.ROUND_HALF_UP)
    
    // Calculate average ON/OFF times for the session
    def avgOn = calculateAverage(state.onDurations)
    def avgOff = calculateAverage(state.offDurations)
    
    // Calculate total runtime if device was detected as ON
    if (state.leftOnDetected && state.cycleHistory && state.cycleHistory.size() > 0 && state.lastActivity) {
        // Get the earliest cycle time (first time device turned on)
        def firstCycleTime = state.cycleHistory.min()
        def totalRuntimeMinutes = new BigDecimal((state.lastActivity - firstCycleTime) / 1000.0 / 60.0).setScale(1, BigDecimal.ROUND_HALF_UP)
        def totalMinutes = totalRuntimeMinutes.toDouble()
        def hours = (totalMinutes / 60).toInteger()
        def minutes = new BigDecimal(totalMinutes % 60).setScale(1, BigDecimal.ROUND_HALF_UP)
        
        if (hours > 0) {
            infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF. Total runtime: ${hours}h ${minutes}m"
        } else {
            infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF. Total runtime: ${totalRuntimeMinutes} minutes"
        }
        
        infolog "Session Stats - Avg ON: ${avgOn}, Avg OFF: ${avgOff}, Total cycles: ${state.cycleHistory.size()}"
        
        state.lastRuntime = totalRuntimeMinutes
        state.lastRuntimeDisplay = hours > 0 ? "${hours}h ${minutes}m" : "${totalRuntimeMinutes}m"
        state.lastAvgOn = avgOn
        state.lastAvgOff = avgOff
    } else {
        infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF."
    }
    
    // Reset everything
    state.cycleHistory = []
    state.onDurations = []
    state.offDurations = []
    state.deviceOn = false
    state.leftOnDetected = false
    
    // Turn off alert switch
    if (alertSwitch.latestValue("switch") == "on") {
        infolog "Turning OFF alert switch"
        alertSwitch.off()
    }
    
    updateAppLabel()
}

def canWeRun() {
    def restrictionOk = true
    def modeOk = true
    
    // Check restriction switch
    if (restrictSwitch) {
        if (restrictSwitch.currentValue('switch') != 'on') {
            restrictionOk = false
            debuglog "Restriction switch is OFF - not running"
        }
    }
    
    // Check mode restrictions
    if (noRunModes) {
        if (noRunModes.contains(location.mode)) {
            modeOk = false
            debuglog "Mode ${location.mode} is restricted - not running"
        }
    }
    
    return (restrictionOk && modeOk)
}

def updateAppLabel() {
    if (!thisName) return
    
    def label = thisName
    def cyclesInWindow = state.cycleHistory?.size() ?: 0
    
    if (state.leftOnDetected) {
        // Alert has been triggered
        def avgOn = calculateAverage(state.onDurations)
        def avgOff = calculateAverage(state.offDurations)
        label += " <span style=\"color:red;\">(LEFT ON - ${cyclesInWindow} cycles - ON:${avgOn}/OFF:${avgOff})</span>"
    } else if (cyclesInWindow > 0) {
        // Cycles detected but not enough yet
        def remaining = cycleCount - cyclesInWindow
        label += " <span style=\"color:orange;\">(${cyclesInWindow}/${cycleCount} cycles - ${remaining} more needed)</span>"
    } else {
        // Normal monitoring - show last runtime if available
        if (state.lastRuntimeDisplay) {
            def statsText = " Last: ${state.lastRuntimeDisplay}"
            if (state.lastAvgOn && state.lastAvgOff) {
                statsText += " (ON:${state.lastAvgOn}/OFF:${state.lastAvgOff})"
            }
            label += " <span style=\"color:green;\">(Monitoring -${statsText})</span>"
        } else {
            label += " <span style=\"color:green;\">(Monitoring - No cycles)</span>"
        }
    }
    
    app.updateLabel(label)
}

def getFormat(type, myText="") {
    if(type == "header-green") return "<div style='color:#ffffff;font-weight: bold;background-color:#81BC00;border: 1px solid;box-shadow: 2px 3px #A9A9A9'>${myText}</div>"
    if(type == "line") return "<hr style='background-color:#1A77C9; height: 1px; border: 0;'>"
    if(type == "title") return "<h2 style='color:#1A77C9;font-weight: bold'>${myText}</h2>"
    if(type == "title2") return "<div style='color:#1A77C9;font-weight: bold'>${myText}</div>"
}

def debuglog(statement) {   
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return}
    else if (logL >= 2) {
        log.debug("$thisName: " + statement)
    }
}

def infolog(statement) {       
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return}
    else if (logL >= 1) {
        log.info("$thisName: " + statement)
    }
}

def getLogLevels() {
    return [["0":"None"],["1":"Running"],["2":"NeedHelp"]]
}
