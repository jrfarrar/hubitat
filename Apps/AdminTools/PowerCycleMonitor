/*
 *	Power Cycle Monitor
 *
 *	Author: J.R. Farrar
 * 
 *  Monitors a device's power cycling pattern and triggers a switch
 *  if the device continues to cycle on/off (indicating it was left on)
 *
 *  V 1.0 - 2025-11-08 - Initial Release
 *  V 1.1 - 2025-11-12 - Added cycle timing tracking (average ON/OFF durations)
 *  V 2.0 - 2025-11-14 - Production Release
 *                     - Fixed BigDecimal rounding issues
 *                     - Fixed null pointer exceptions on upgrade
 *                     - Fixed OFF duration calculation including idle time
 *                     - Added current statistics display
 *                     - Added manual reset capability
 *                     - Enhanced error handling and validation
 *                     - Improved logging with context
 * 
 */

definition(
  name: "Power Cycle Monitor Child",
  namespace: "jrfarrar",
  author: "J.R. Farrar",
  description: "Monitor power cycling and trigger switch if device is left on",
  parent: "jrfarrar:Admin tools",    
  iconUrl: "",
  iconX2Url: "",
  iconX3Url: "",
  importUrl: ""
)


preferences {
    page(name: "pageConfig")
}

def pageConfig() {
    dynamicPage(name: "", title: "", install: true, uninstall: true, refreshInterval:0) { 
        
        section(getFormat("header-green", "DEVICES")) {
            paragraph "Monitor a power meter for cycling patterns. If device cycles on/off repeatedly, it indicates it was 'left on'."
            input (name: "pwrMeter", type: "capability.powerMeter", title: "Power Meter to Monitor", submitOnChange: true, required: true)
            input (name: "alertSwitch", type: "capability.switch", title: "Switch to turn ON when cycling detected", submitOnChange: true, required: true, multiple: false)
        }
        
        section(getFormat("header-green", "CYCLE DETECTION SETTINGS")) {
            paragraph "Device is considered 'left on' if it cycles multiple times within a time window"
            input (name: "watts", type: "number", title: "Watt threshold (power above = ON, below = OFF)", required: true, defaultValue: 100, range: "1..10000")
            input (name: "cycleCount", type: "number", title: "Number of cycles to detect", required: true, defaultValue: 3, range: "2..20", description: "How many on/off cycles indicate 'left on'")
            input (name: "timeWindow", type: "number", title: "Time window in minutes", required: true, defaultValue: 30, range: "5..180", description: "Cycles must occur within this time window")
            input (name: "offTimeout", type: "number", title: "Minutes off before considering 'turned off'", required: true, defaultValue: 60, range: "5..480", description: "If no cycles for this long, device is considered off")
        }
        
        if (state.leftOnDetected || (state.cycleHistory && state.cycleHistory.size() > 0)) {
            section(getFormat("header-green", "CURRENT STATUS")) {
                def status = getCurrentStatusText()
                paragraph getFormat("title2", status)
                
                if (state.leftOnDetected) {
                    paragraph "<b>Alert Active Since:</b> ${state.alertTime}"
                }
                
                def cyclesInWindow = state.cycleHistory?.size() ?: 0
                if (cyclesInWindow > 0) {
                    paragraph "<b>Cycles in Window:</b> ${cyclesInWindow} of ${cycleCount} needed"
                    
                    def avgOn = calculateAverage(state.onDurations)
                    def avgOff = calculateAverage(state.offDurations)
                    if (avgOn != "N/A" || avgOff != "N/A") {
                        paragraph "<b>Average Times:</b> ON: ${avgOn}, OFF: ${avgOff}"
                    }
                }
                
                if (state.lastRuntimeDisplay) {
                    paragraph "<b>Last Session Runtime:</b> ${state.lastRuntimeDisplay}"
                    if (state.lastAvgOn && state.lastAvgOff) {
                        paragraph "<b>Last Session Averages:</b> ON: ${state.lastAvgOn}, OFF: ${state.lastAvgOff}"
                    }
                }
                
                input (name: "btnReset", type: "button", title: "Reset Statistics", width: 4)
            }
        }
        
        section(getFormat("header-green", "RESTRICTIONS")) {
            paragraph "Optional: Restrict when this monitor is active"
            input (name: "restrictSwitch", type: "capability.switch", title: "Only run when this switch is ON", submitOnChange: true, required: false, multiple: false)
            input (name: "noRunModes", type: "mode", title: "Do NOT run in these modes", submitOnChange: true, required: false, multiple: true)
        }
        
        section(getFormat("header-green", "LOGGING")){                       
            input(name: "logLevel", title: "IDE logging level", multiple: false, required: true, type: "enum", options: getLogLevels(), submitOnChange: false, defaultValue: "1")
        }
        
        section(getFormat("header-green", "APP NAME")){
            input (name: "thisName", type: "text", title: "App Name", submitOnChange: true)
            if(thisName) {
                app.updateLabel("$thisName")
            } else {
                app.updateSetting("thisName", "Power Cycle Monitor")
            }
        }
    }  
}

def appButtonHandler(btn) {
    switch(btn) {
        case "btnReset":
            infolog "Manual reset requested"
            resetStatistics()
            break
    }
}

def installed() {
    infolog "installed - version 2.0"
    initialize()
}

def updated() {
    infolog "updated - version 2.0"
    unsubscribe()
    unschedule()
    initialize()
}

def initialize() {
    infolog "initialize"
    unschedule() 
    unsubscribe()
    subscribeToEvents()
    
    // Initialize all state variables with null-safe defaults
    if (state.deviceOn == null) state.deviceOn = false
    if (!state.cycleHistory) state.cycleHistory = []
    if (!state.onDurations) state.onDurations = []
    if (!state.offDurations) state.offDurations = []
    // Don't initialize lastStateChangeTime - let it be null so first duration calc is skipped
    if (state.leftOnDetected == null) state.leftOnDetected = false
    if (!state.lastActivity) state.lastActivity = now()
    
    // Validate settings
    validateSettings()
    
    updateAppLabel()
}

def uninstalled() {
    unschedule()
    unsubscribe()
    infolog "uninstalled"
}

def subscribeToEvents() {
    if (pwrMeter) {
        subscribe(pwrMeter, "power", powerHandler)
        infolog "Subscribed to power meter: ${pwrMeter.displayName}"
    } else {
        log.warn "No power meter selected for monitoring"
    }
}

def validateSettings() {
    def issues = []
    
    if (!pwrMeter) issues.add("No power meter selected")
    if (!alertSwitch) issues.add("No alert switch selected")
    if (watts && (watts < 1 || watts > 10000)) issues.add("Watt threshold out of range")
    if (cycleCount && (cycleCount < 2 || cycleCount > 20)) issues.add("Cycle count out of range")
    if (timeWindow && (timeWindow < 5 || timeWindow > 180)) issues.add("Time window out of range")
    if (offTimeout && (offTimeout < 5 || offTimeout > 480)) issues.add("Off timeout out of range")
    
    if (issues.size() > 0) {
        log.warn "Configuration issues: ${issues.join(', ')}"
    } else {
        debuglog "Configuration validated successfully"
    }
}

def powerHandler(evt) {
    // Check if we can run based on restrictions
    if (!canWeRun()) {
        debuglog "Restrictions prevent running"
        return
    }
    
    // Parse and validate power reading
    def dblePower = 0.0
    try {
        dblePower = Double.parseDouble(evt.value)
    } catch (Exception e) {
        log.error "Failed to parse power value '${evt.value}': ${e.message}"
        return
    }
    
    def rndPower = Math.round(dblePower)
    debuglog "Power: ${rndPower}W from ${evt.device.displayName}"
    
    // Sanity check - ignore erroneous readings
    if (rndPower < 0 || rndPower > 10000) {
        log.warn "Ignoring erroneous power reading: ${rndPower}W from ${evt.device.displayName}"
        return
    }
    
    // Determine if device is currently ON or OFF
    def isOn = (rndPower > watts)
    def currentTime = now()
    
    // Detect state change (cycle)
    if (isOn && !state.deviceOn) {
        // Device just turned ON - calculate OFF duration
        if (state.lastStateChangeTime) {
            def offDuration = (currentTime - state.lastStateChangeTime) / 1000.0 / 60.0 // minutes
            
            // Initialize array if it doesn't exist (for upgrades from old version)
            if (!state.offDurations) {
                state.offDurations = []
            }
            
            state.offDurations.add(offDuration)
            
            // Keep list size reasonable
            if (state.offDurations.size() > cycleCount * 2) {
                state.offDurations = state.offDurations.drop(1)
            }
            
            debuglog "OFF duration: ${String.format('%.2f', offDuration)} minutes"
        }
        
        state.deviceOn = true
        state.lastStateChangeTime = currentTime
        state.lastActivity = currentTime
        recordCycle()
        infolog "Device turned ON (${rndPower}W)"
        
        // Schedule check for timeout (device truly off)
        unschedule(checkDeviceOff)
        runIn(60 * offTimeout.toInteger(), checkDeviceOff)
        
    } else if (!isOn && state.deviceOn) {
        // Device just turned OFF - calculate ON duration
        if (state.lastStateChangeTime) {
            def onDuration = (currentTime - state.lastStateChangeTime) / 1000.0 / 60.0 // minutes
            
            // Initialize array if it doesn't exist (for upgrades from old version)
            if (!state.onDurations) {
                state.onDurations = []
            }
            
            state.onDurations.add(onDuration)
            
            // Keep list size reasonable
            if (state.onDurations.size() > cycleCount * 2) {
                state.onDurations = state.onDurations.drop(1)
            }
            
            debuglog "ON duration: ${String.format('%.2f', onDuration)} minutes"
        }
        
        state.deviceOn = false
        state.lastStateChangeTime = currentTime
        infolog "Device turned OFF (${rndPower}W)"
    }
    
    // Check if we've detected enough cycles to indicate "left on"
    evaluateCyclePattern()
}

def recordCycle() {
    // Add current time to cycle history
    def currentTime = now()
    
    if (!state.cycleHistory) {
        state.cycleHistory = []
    }
    
    state.cycleHistory.add(currentTime)
    
    // Remove old cycles outside the time window
    def windowMillis = timeWindow * 60 * 1000
    state.cycleHistory = state.cycleHistory.findAll { cycleTime ->
        (currentTime - cycleTime) < windowMillis
    }
    
    debuglog "Cycle recorded. Total cycles in last ${timeWindow} minutes: ${state.cycleHistory.size()}"
}

def evaluateCyclePattern() {
    def cyclesInWindow = state.cycleHistory?.size() ?: 0
    
    if (cyclesInWindow >= cycleCount && !state.leftOnDetected) {
        // Device has cycled enough times - it's "left on"
        state.leftOnDetected = true
        state.onStartTime = now()  // Record when device officially turned ON
        state.alertTime = new Date().format("yyyy-MM-dd HH:mm:ss")
        
        // Calculate and log average ON/OFF times
        def avgOn = calculateAverage(state.onDurations)
        def avgOff = calculateAverage(state.offDurations)
        
        infolog "ALERT: Device has cycled ${cyclesInWindow} times in ${timeWindow} minutes! Device appears to be LEFT ON."
        infolog "Cycle Stats - Avg ON time: ${avgOn}, Avg OFF time: ${avgOff}"
        
        // Turn on alert switch
        try {
            if (alertSwitch.currentValue("switch") != "on") {
                alertSwitch.on()
                infolog "Alert switch turned ON"
            }
        } catch (Exception e) {
            log.error "Failed to turn on alert switch: ${e.message}"
        }
        
        updateAppLabel()
    }
}

def calculateAverage(List durations) {
    if (!durations || durations.size() == 0) {
        return "N/A"
    }
    
    def sum = durations.sum()
    def avg = sum / durations.size()
    
    // Convert to double to avoid BigDecimal rounding issues
    def avgDouble = avg.toDouble()
    
    // Format nicely based on magnitude
    if (avgDouble < 1.0) {
        return "${Math.round(avgDouble * 60)} seconds"
    } else if (avgDouble < 60) {
        return "${String.format('%.1f', avgDouble)} minutes"
    } else {
        def hours = (avgDouble / 60).toInteger()
        def minutes = Math.round(avgDouble % 60)
        return "${hours}h ${minutes}m"
    }
}

def checkDeviceOff() {
    // This runs if no activity for offTimeout minutes
    def minutesSinceActivity = new BigDecimal((now() - state.lastActivity) / 1000.0 / 60.0).setScale(1, BigDecimal.ROUND_HALF_UP)
    
    infolog "Checking device status - ${minutesSinceActivity} minutes since last activity"
    
    // Calculate average ON/OFF times for the session
    def avgOn = calculateAverage(state.onDurations)
    def avgOff = calculateAverage(state.offDurations)
    
    // Calculate total runtime if device was detected as ON
    if (state.leftOnDetected && state.cycleHistory && state.cycleHistory.size() > 0 && state.lastActivity) {
        // Get the earliest cycle time (first time device turned on)
        def firstCycleTime = state.cycleHistory.min()
        def totalRuntimeMinutes = new BigDecimal((state.lastActivity - firstCycleTime) / 1000.0 / 60.0).setScale(1, BigDecimal.ROUND_HALF_UP)
        def totalMinutes = totalRuntimeMinutes.toDouble()
        def hours = (totalMinutes / 60).toInteger()
        def minutes = new BigDecimal(totalMinutes % 60).setScale(1, BigDecimal.ROUND_HALF_UP)
        
        if (hours > 0) {
            infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF. Total runtime: ${hours}h ${minutes}m"
        } else {
            infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF. Total runtime: ${totalRuntimeMinutes} minutes"
        }
        
        infolog "Session Stats - Avg ON: ${avgOn}, Avg OFF: ${avgOff}, Total cycles: ${state.cycleHistory.size()}"
        
        state.lastRuntime = totalRuntimeMinutes
        state.lastRuntimeDisplay = hours > 0 ? "${hours}h ${minutes}m" : "${totalRuntimeMinutes}m"
        state.lastAvgOn = avgOn
        state.lastAvgOff = avgOff
    } else {
        infolog "No activity detected for ${minutesSinceActivity} minutes. Device appears to be truly OFF."
    }
    
    // Reset everything for next session
    state.cycleHistory = []
    state.onDurations = []
    state.offDurations = []
    state.deviceOn = false
    state.leftOnDetected = false
    state.lastStateChangeTime = null  // Critical: reset so next cycle doesn't include idle time
    
    // Turn off alert switch
    try {
        if (alertSwitch.currentValue("switch") == "on") {
            infolog "Turning OFF alert switch"
            alertSwitch.off()
        }
    } catch (Exception e) {
        log.error "Failed to turn off alert switch: ${e.message}"
    }
    
    updateAppLabel()
}

def resetStatistics() {
    infolog "Resetting all statistics"
    
    // Clear current session data
    state.cycleHistory = []
    state.onDurations = []
    state.offDurations = []
    state.deviceOn = false
    state.leftOnDetected = false
    state.lastStateChangeTime = null
    
    // Clear historical data
    state.lastRuntime = null
    state.lastRuntimeDisplay = null
    state.lastAvgOn = null
    state.lastAvgOff = null
    state.alertTime = null
    state.onStartTime = null
    
    // Turn off alert switch if it's on
    try {
        if (alertSwitch && alertSwitch.currentValue("switch") == "on") {
            alertSwitch.off()
            infolog "Alert switch turned OFF"
        }
    } catch (Exception e) {
        log.error "Failed to turn off alert switch: ${e.message}"
    }
    
    // Cancel any pending timeout checks
    unschedule(checkDeviceOff)
    
    updateAppLabel()
    infolog "Statistics reset complete"
}

def canWeRun() {
    def restrictionOk = true
    def modeOk = true
    
    // Check restriction switch
    if (restrictSwitch) {
        try {
            if (restrictSwitch.currentValue('switch') != 'on') {
                restrictionOk = false
                debuglog "Restriction switch is OFF - not running"
            }
        } catch (Exception e) {
            log.error "Error checking restriction switch: ${e.message}"
            restrictionOk = false
        }
    }
    
    // Check mode restrictions
    if (noRunModes) {
        if (noRunModes.contains(location.mode)) {
            modeOk = false
            debuglog "Mode ${location.mode} is restricted - not running"
        }
    }
    
    return (restrictionOk && modeOk)
}

def getCurrentStatusText() {
    if (state.leftOnDetected) {
        return "ðŸ”´ ALERT ACTIVE - Device is cycling and appears to be LEFT ON"
    } else if (state.cycleHistory && state.cycleHistory.size() > 0) {
        def remaining = cycleCount - state.cycleHistory.size()
        return "ðŸŸ¡ MONITORING - ${remaining} more cycle(s) needed to trigger alert"
    } else {
        return "ðŸŸ¢ MONITORING - No active cycles detected"
    }
}

def updateAppLabel() {
    if (!thisName) return
    
    def label = thisName
    def cyclesInWindow = state.cycleHistory?.size() ?: 0
    
    if (state.leftOnDetected) {
        // Alert has been triggered
        def avgOn = calculateAverage(state.onDurations)
        def avgOff = calculateAverage(state.offDurations)
        label += " <span style=\"color:red;\">(ALERT: ${cyclesInWindow} cycles - ON:${avgOn}/OFF:${avgOff})</span>"
    } else if (cyclesInWindow > 0) {
        // Cycles detected but not enough yet
        def remaining = cycleCount - cyclesInWindow
        label += " <span style=\"color:orange;\">(${cyclesInWindow}/${cycleCount} cycles - ${remaining} more needed)</span>"
    } else {
        // Normal monitoring - show last runtime if available
        if (state.lastRuntimeDisplay) {
            def statsText = "Last: ${state.lastRuntimeDisplay}"
            if (state.lastAvgOn && state.lastAvgOff) {
                statsText += " (ON:${state.lastAvgOn}/OFF:${state.lastAvgOff})"
            }
            label += " <span style=\"color:green;\">(${statsText})</span>"
        } else {
            label += " <span style=\"color:green;\">(Monitoring)</span>"
        }
    }
    
    app.updateLabel(label)
}

def getFormat(type, myText="") {
    if(type == "header-green") return "<div style='color:#ffffff;font-weight: bold;background-color:#81BC00;border: 1px solid;box-shadow: 2px 3px #A9A9A9'>${myText}</div>"
    if(type == "line") return "<hr style='background-color:#1A77C9; height: 1px; border: 0;'>"
    if(type == "title") return "<h2 style='color:#1A77C9;font-weight: bold'>${myText}</h2>"
    if(type == "title2") return "<div style='color:#1A77C9;font-weight: bold'>${myText}</div>"
}

def debuglog(statement) {   
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return}
    else if (logL >= 2) {
        log.debug("${app.label}: ${statement}")
    }
}

def infolog(statement) {       
    def logL = 0
    if (logLevel) logL = logLevel.toInteger()
    if (logL == 0) {return}
    else if (logL >= 1) {
        log.info("${app.label}: ${statement}")
    }
}

def getLogLevels() {
    return [["0":"None"],["1":"Running"],["2":"NeedHelp"]]
}
