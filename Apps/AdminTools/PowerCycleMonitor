// hubitat start
// hub: 192.168.13.36
// type: app
// id: 390
// hubitat end

/**
 * Power Cycle Monitor v2.36 (Smart Dashboard)
 *
 * Monitor power meters to detect cycling patterns and stuck-on failures
 * with historical tracking and trend analysis.
 *
 * v2.36 Changes:
 * - FEATURE: Split reset functionality into two clearly labeled buttons
 * - NEW: "Clear Recent Sessions Table" button (below Recent Sessions section)
 * - NEW: "Reset All Historical Data" button (at bottom with warnings)
 * - UI: Clear descriptions explain exactly what each reset button does
 * - SAFETY: Historical reset now includes warning message before action
 *
 * v2.35 Changes:
 * - UI: Renamed "History & Trends" to "Historical Analysis and Anomaly Detection"
 * - UI: Renamed "System Status" to "Current Session"
 * - UI: Moved CSV Logging section to separate section below Monthly History
 * - UI: CSV Logging is now a standalone section (not nested in Historical Analysis)
 *
 * v2.34 Changes:
 * - UI: Major layout reorganization for a more logical and intuitive user experience.
 * - FEATURE: Separated "Historical Analysis" from "CSV Logging" with independent controls.
 * - FIX: Proper section nesting using styled headers (Hubitat limitation workaround)
 */

import java.math.RoundingMode

definition(
        name: "Power Cycle Monitor",
        namespace: "jrfarrar",
        author: "J.R. Farrar",
        description: "Monitor power meters to detect cycling patterns and stuck-on failures with historical tracking",
        category: "Convenience",
        iconUrl: "",
        iconX2Url: "",
        iconX3Url: ""
)

preferences {
    page(name: "mainPage")
    page(name: "toggleHistoryDisplay")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Power Cycle Monitor v2.36", install: true, uninstall: true) {

        // 1. Device to Monitor
        section("Device to Monitor") {
            input "powerMeter", "capability.powerMeter", title: "Select Power Meter", required: true, multiple: false
            input "wattThreshold", "number", title: "Watt Threshold (ON > this)", required: true, defaultValue: 100, description: "Watts"
        }

        // 2. Cycling Detection (Usage Monitor)
        section("Cycling Detection (Usage Monitor)") {
            input "cycleCount", "number", title: "Cycles to Log/Alert", required: true, defaultValue: 3, description: "Sessions with fewer cycles will be ignored"
            input "timeWindow", "number", title: "Time Window (minutes)", required: true, defaultValue: 30
            input "offTimeout", "number", title: "Reset triggers if OFF for (min)", required: true, defaultValue: 60
            input "cycleAlertSwitch", "capability.switch", title: "Active Usage Switch (Optional)", required: false, description: "Turns ON when cycling detected"
        }

        // 3. Stuck-ON Detection (Failure Monitor)
        section("Stuck-ON Detection (Failure Monitor)") {
            input "stuckOnTimeout", "number", title: "Alert if ON longer than (min)", required: true, defaultValue: 15
            input "stuckOnAlertSwitch", "capability.switch", title: "Stuck-ON Switch (Optional)", required: false, description: "Turns ON when stuck detected"
        }

        // 4. Current Session (always visible)
        section("Current Session") {
            paragraph getSmartDashboardHtml()
        }

        // 5. Recent Sessions (always visible)
        section("Recent Sessions") {
            if (!state.recentSessions) state.recentSessions = []

            if (state.recentSessions.size() == 0) {
                paragraph "<div style='background-color:#f0f0f0; padding:10px; border-radius:5px; margin-top:-10px;'><b>No session history yet...</b><br>Completed sessions will be shown here.</div>"
            } else {
                paragraph getHistoryTableHtml()
            }
            
            // Reset Recent Sessions button with description
            paragraph "<hr style='margin-top:15px; margin-bottom:10px;'>"
            input "btnResetRecent", "button", title: "Clear Recent Sessions Table"
            paragraph "<small style='color:#666;'>Clears only the table above and ends the current active session. All historical data (Monthly History, Baseline, CSV files) is preserved.</small>"
        }

        // 6. Historical Analysis and Anomaly Detection (master section for optional features)
        section("Historical Analysis and Anomaly Detection") {
            input "enableHistoryTracking", "bool", title: "Enable Historical Analysis", defaultValue: true, submitOnChange: true
            
            if (settings.enableHistoryTracking) {
                // Anomaly Detection
                paragraph "<div style='font-weight:bold; margin-top:15px; margin-bottom:10px; font-size:1.1em;'>Anomaly Detection</div>"
                input "anomalyThreshold", "number", title: "Anomaly Threshold (%)", range: "15..50", required: true, defaultValue: 25
                input "anomalySwitch", "capability.switch", title: "Anomaly Switch (Latching)", required: false
                
                // Baseline Management
                paragraph "<div style='font-weight:bold; margin-top:15px; margin-bottom:10px; font-size:1.1em;'>Baseline Management</div>"
                input "lockBaseline", "bool", title: "Lock Current Baseline", defaultValue: false, submitOnChange: true
                paragraph getBaselineDisplayHtml()
            }
        }

        // 7. Monthly History (only if Historical Analysis enabled)
        if (settings.enableHistoryTracking) {
            section("Monthly History") {
                if (!state.monthlySnapshots) state.monthlySnapshots = []

                def monthsToShow = state.showFullHistory ? 12 : 6

                if (state.monthlySnapshots.size() == 0) {
                    paragraph "<div style='background-color:#f0f0f0; padding:10px; border-radius:5px; margin-top:-10px;'><b>Establishing Baseline...</b><br>Need at least 2 months of data for trend analysis.<br>Sessions this month: ${state.sessionsThisMonth ?: 0}</div>"
                } else {
                    paragraph getMonthlyHistoryTableHtml(monthsToShow)

                    // Toggle button for 6/12 months
                    if (state.monthlySnapshots.size() > 6) {
                        def btnText = state.showFullHistory ? "Show Less" : "Show 12 Months"
                        href name: "btnToggleHistory", title: btnText, description: "", page: "toggleHistoryDisplay"
                    }
                }
            }
            
            // 8. CSV Logging (only if Historical Analysis enabled)
            section("CSV Logging") {
                input "enableCsvLogging", "bool", title: "Enable CSV File Logging", defaultValue: true, submitOnChange: true
                
                // CSV download link - RIGHT UNDER the CSV logging switch
                if (settings.enableCsvLogging) {
                    def fileName = getFileName()
                    def fileUrl = getFileManagerUrl(fileName)
                    paragraph "<div style='text-align:left; margin-top:5px;'><a href='${fileUrl}' target='_blank' style='font-weight:bold; text-decoration:none;'>üì• Download Full History (CSV)</a></div>"
                }
            }
        }

        // 9. Reset Historical Data
        section("‚ö†Ô∏è Reset Historical Data") {
            paragraph "<div style='background-color:#fff3cd; padding:10px; border-radius:5px; border-left:4px solid #ff9800;'><b>Warning:</b> This action will permanently delete all historical tracking data including Monthly History, Baseline calculations, and monthly snapshots. CSV log files will remain on disk but can be manually deleted.</div>"
            input "btnResetHistory", "button", title: "‚ö†Ô∏è Reset All Historical Data"
            paragraph "<small style='color:#666;'>This will clear: Monthly History table, Baseline data, all monthly snapshots, and monthly counters. This action cannot be undone. Recent Sessions and CSV files are not affected.</small>"
        }

        // 10. App Settings
        section("App Settings") {
            input "labelPrefix", "text", title: "App Label Prefix", required: false
            input "logEnable", "bool", title: "Enable Debug Logging", defaultValue: false
        }
    }
}

def toggleHistoryDisplay() {
    state.showFullHistory = !state.showFullHistory
    mainPage()
}

// ----------------------------------------------------------------------------
//   DISPLAY HELPERS (SMART DASHBOARD)
// ----------------------------------------------------------------------------

def getSmartDashboardHtml() {
    def status = getSystemStatus()
    def row = ""

    if (state.deviceOn || state.sessionCycleCount > 0) {
        def cycles = state.sessionCycleCount
        def avgOn = getAverage(state.onDurations)
        def avgOff = (state.sessionCycleCount > 1) ? "${String.format('%.1f', getAverage(state.offDurations))}s" : "N/A"
        def runtime = state.deviceOn ? getOnDuration() : "${String.format('%.1f', (avgOn * cycles) / 60.0)}m"
        
        row = "<tr><td style='color:${status.color};'>Live</td><td>${cycles}</td><td>${String.format('%.1f', avgOn)}s</td><td>${avgOff}</td><td>${runtime}</td></tr>"
    } else {
        if (state.lastSessionStats) {
            def stats = state.lastSessionStats
            row = "<tr><td>${stats.time}</td><td>${stats.cycles}</td><td>${stats.avgOn}s</td><td>${stats.avgOff}s</td><td>${stats.runtime}m</td></tr>"
        } else {
            return "<div style='background-color:#f0f0f0; padding:10px; border-radius:5px; margin-top:-10px;'><b>Waiting for first run...</b></div>"
        }
    }

    return """
    <table style='width:100%; font-size:0.9em; border-collapse:collapse; margin-top:-10px;' border='1' bordercolor='#ddd'>
        <tr style='background-color:#f5f5f5; font-weight:bold;'>
            <td>Time</td><td>Cycles</td><td>Avg On</td><td>Avg Off</td><td>Runtime</td>
        </tr>
        ${row}
    </table>
    """
}

def getBaselineDisplayHtml() {
    def bCycle = state.baselineCycleTime ? "${safeToBigDecimal(state.baselineCycleTime).setScale(1, RoundingMode.HALF_UP)}s" : "N/A"
    def bOn = state.baselineAvgOn ? "${safeToBigDecimal(state.baselineAvgOn).setScale(0, RoundingMode.HALF_UP)}s" : "N/A"
    def bOff = state.baselineAvgOff ? "${safeToBigDecimal(state.baselineAvgOff).setScale(0, RoundingMode.HALF_UP)}s" : "N/A"
    def statusText = lockBaseline ? "(Locked)" : "(Dynamic)"

    return "Current Baseline ${statusText}: ${bCycle} Cycle (${bOn} ON / ${bOff} OFF)"
}

def getHistoryTableHtml() {
    def rows = ""
    state.recentSessions.each { sess ->
        rows += "<tr>"
        rows += "<td>${sess.time}</td>"
        rows += "<td>${sess.cycles}</td>"
        rows += "<td>${sess.avgOn}s</td>"
        rows += "<td>${sess.avgOff}s</td>"
        rows += "<td>${sess.runtime}m</td>"
        rows += "</tr>"
    }

    return """
    <table style='width:100%; font-size:0.9em; border-collapse:collapse; margin-top:-10px;' border='1' bordercolor='#ddd'>
        <tr style='background-color:#f5f5f5; font-weight:bold;'>
            <td>Time</td><td>Cycles</td><td>Avg On</td><td>Avg Off</td><td>Runtime</td>
        </tr>
        ${rows}
    </table>
    """
}

def getMonthlyHistoryTableHtml(limit) {
    def rows = ""
    def list = state.monthlySnapshots.take(limit)

    list.each { snap ->
        def warn = (snap.stuckOnEvents > 0) ? "!" : ""
        def anom = (snap.anomaly) ? "!" : ""
        def bg = (snap.stuckOnEvents > 0 || snap.anomaly) ? "#fff0f0" : "#ffffff"

        rows += "<tr style='background-color:${bg}'>"
        rows += "<td>${snap.monthYear}</td>"
        rows += "<td>${snap.cycles}</td>"
        rows += "<td>${Math.round(safeToBigDecimal(snap.avgOn))}s</td>"
        rows += "<td>${Math.round(safeToBigDecimal(snap.avgOff))}s</td>"
        rows += "<td>${snap.sessionsPerDay}</td>"
        rows += "<td>${warn}${anom}</td>"
        rows += "</tr>"
    }

    return """
    <table style='width:100%; font-size:0.9em; border-collapse:collapse; margin-top:-10px;' border='1' bordercolor='#ddd'>
        <tr style='background-color:#f5f5f5; font-weight:bold;'>
            <td>Month</td><td>Cyc</td><td>On</td><td>Off</td><td>/Day</td><td>Alert</td>
        </tr>
        ${rows}
    </table>
    """
}


// ----------------------------------------------------------------------------
//   CORE LOGIC & HANDLERS
// ----------------------------------------------------------------------------

def installed() {
    initialize()
}

def updated() {
    unsubscribe()
    unschedule()
    initialize()
}

def initialize() {
    logDebug "Initializing..."

    if (state.deviceOn == null) state.deviceOn = false
    if (!state.cycleHistory) state.cycleHistory = []
    if (!state.onDurations) state.onDurations = []
    if (!state.offDurations) state.offDurations = []
    if (state.sessionCycleCount == null) state.sessionCycleCount = 0
    if (!state.recentSessions) state.recentSessions = []

    if (enableHistoryTracking) {
        if (!state.monthlySnapshots) state.monthlySnapshots = []
        if (!state.currentMonthSessions) state.currentMonthSessions = []
        if (!state.currentMonth) state.currentMonth = new Date().format("yyyy-MM")

        schedule("0 0 1 1 * ?", "checkMonthRollover") // Run yearly, but we check monthly
    }

    subscribe(powerMeter, "power", powerHandler)
    runEvery5Minutes("heartbeat")
    updateAppLabel()
}

def powerHandler(evt) {
    def power = safeToBigDecimal(evt.value)
    def currentTime = now()

    state.lastActivity = currentTime
    checkDayRollover()

    if (power >= wattThreshold) {
        handleDeviceOn(currentTime, power)
    } else {
        handleDeviceOff(currentTime)
    }
}

def handleDeviceOn(currentTime, power) {
    if (!state.currentSessionWattages) state.currentSessionWattages = []
    state.currentSessionWattages.add(power)

    if (!state.deviceOn) {
        log.info "${powerMeter} turned ON (power: ${power}W)"
        state.deviceOn = true
        state.continuousOnStart = currentTime

        // Pressure Tank Logic (Ignore long idle)
        if (state.lastStateChangeTime) {
            def offSeconds = (currentTime - state.lastStateChangeTime) / 1000.0
            def thresholdSeconds = offTimeout * 60

            if (offSeconds < thresholdSeconds) {
                state.offDurations.add(offSeconds)
                logDebug "OFF Duration: ${formatDuration(offSeconds)} (Recorded)"
            } else {
                logDebug "OFF Duration: ${formatDuration(offSeconds)} (Ignored - exceeded idle threshold)"
                if (state.sessionCycleCount == 0) {
                    state.onDurations = []
                    state.offDurations = []
                }
            }
        }

        state.lastStateChangeTime = currentTime

        if (state.stuckOnDetected) {
            log.warn "Stuck-ON Cleared: Device cycled off/on."
            state.stuckOnDetected = false
            if (stuckOnAlertSwitch) stuckOnAlertSwitch.off()
        }

        runInMillis((stuckOnTimeout * 60 * 1000).toInteger(), "checkStuckOn")
        updateAppLabel()
    }
}

def handleDeviceOff(currentTime) {
    if (state.deviceOn) {
        def onSeconds = (currentTime - state.continuousOnStart) / 1000.0
        def avgWatts = getAverage(state.currentSessionWattages)
        def peakWatts = state.currentSessionWattages.max()

        log.info "${powerMeter} turned OFF. Last run: ${formatDuration(onSeconds)}, Avg Power: ${avgWatts.toInteger()}W, Peak: ${peakWatts.toInteger()}W"
        state.deviceOn = false

        if (state.continuousOnStart) {
            state.onDurations.add(onSeconds)
        }

        state.lastStateChangeTime = currentTime
        state.continuousOnStart = null

        recordCycle(currentTime)
        checkForCyclingAlert()
        updateAppLabel()
    }
}

def recordCycle(currentTime) {
    if (!state.cycleHistory) state.cycleHistory = []
    state.cycleHistory.add(currentTime)
    state.sessionCycleCount = (state.sessionCycleCount ?: 0) + 1

    def windowMs = timeWindow * 60 * 1000
    state.cycleHistory = state.cycleHistory.findAll { it > (currentTime - windowMs) }

    if (state.sessionCycleCount == 1) {
        log.info "--- NEW SESSION STARTED ---"
    }

    log.info "Cycle #${state.sessionCycleCount} | Window: ${state.cycleHistory.size()}/${cycleCount}"
}

def checkForCyclingAlert() {
    if (state.cycleHistory.size() >= cycleCount && !state.leftOnDetected) {
        log.info "CYCLING DETECTED: ${state.cycleHistory.size()} cycles detected in ${timeWindow} min (Usage Monitor)"
        state.leftOnDetected = true
        if (cycleAlertSwitch) cycleAlertSwitch.on()
    }
}

def checkStuckOn() {
    if (!state.deviceOn || !state.continuousOnStart) return

    def onDurationMinutes = (now() - state.continuousOnStart) / 1000.0 / 60.0

    if (onDurationMinutes >= stuckOnTimeout && !state.stuckOnDetected) {
        log.warn "STUCK-ON ALERT: Device ON for ${String.format('%.1f', onDurationMinutes)} min"
        state.stuckOnDetected = true

        if (stuckOnAlertSwitch) stuckOnAlertSwitch.on()

        if (enableHistoryTracking) {
            recordSessionData("stuck-on")
        }

        updateAppLabel()
    }
}

def heartbeat() {
    checkDeviceOffReset()
    if (state.deviceOn && !state.stuckOnDetected) {
        checkStuckOn()
    }
}

def checkDeviceOffReset() {
    if (state.deviceOn) return
    if (!state.lastActivity) return

    def minsSinceActivity = (now() - state.lastActivity) / 1000.0 / 60.0

    if (minsSinceActivity >= offTimeout && (state.sessionCycleCount > 0 || state.leftOnDetected)) {
        log.info "--- SESSION ENDED (${String.format('%.1f', minsSinceActivity)}m idle) ---"
        finishSession()
    }
}

def finishSession() {
    // 1. Capture Last Session Stats for Dashboard (Memory Only)
    if (state.sessionCycleCount > 0) {
        def avgOn = getAverage(state.onDurations)
        def avgOff = getAverage(state.offDurations)
        def totalSeconds = (avgOn * state.sessionCycleCount) + (avgOff * state.sessionCycleCount)

        def session = [
                time: new Date().format("h:mm a"),
                cycles: state.sessionCycleCount,
                avgOn: String.format('%.1f', avgOn),
                avgOff: String.format('%.1f', avgOff),
                runtime: String.format('%.1f', totalSeconds / 60.0)
        ]
        state.lastSessionStats = session

        if (!state.recentSessions) state.recentSessions = []
        state.recentSessions.add(0, session)
        if (state.recentSessions.size() > 10) state.recentSessions = state.recentSessions.take(10)
    }

    // 2. Log to CSV only if it meets threshold
    if (enableHistoryTracking) {
        if (state.sessionCycleCount >= cycleCount) {
            recordSessionData("normal")
        } else {
            logDebug "Ignored session with ${state.sessionCycleCount} cycles (Threshold: ${cycleCount})"
        }
    }

    // 3. Reset
    state.cycleHistory = []
    state.sessionCycleCount = 0
    state.onDurations = []
    state.offDurations = []
    state.leftOnDetected = false
    state.currentSessionWattages = []

    if (cycleAlertSwitch && cycleAlertSwitch.currentValue("switch") == "on") {
        cycleAlertSwitch.off()
    }

    if (state.anomalyDetected) {
        state.anomalyDetected = false
        state.anomalyMessage = null
    }

    updateAppLabel()
}

// ----------------------------------------------------------------------------
//   DATA LOGGING & BASELINE
// ----------------------------------------------------------------------------

def recordSessionData(type) {
    def data = [:]
    data.timestamp = new Date().format("yyyy-MM-dd HH:mm:ss")
    data.type = type

    if (type == "stuck-on") {
        data.cycles = 0
        data.avgOn = state.continuousOnStart ? (now() - state.continuousOnStart) / 1000.0 : 0.0
        data.avgOff = 0.0
        data.runtime = data.avgOn / 60.0
        state.stuckOnEventCountThisMonth = (state.stuckOnEventCountThisMonth ?: 0) + 1
    } else {
        data.cycles = state.sessionCycleCount ?: 0
        data.avgOn = getAverage(state.onDurations)
        data.avgOff = getAverage(state.offDurations)

        def totalSeconds = (data.avgOn * data.cycles) + (data.avgOff * data.cycles)
        data.runtime = totalSeconds / 60.0
    }

    if (!state.currentMonthSessions) state.currentMonthSessions = []
    state.currentMonthSessions.add(data)
    state.sessionsThisMonth = (state.sessionsThisMonth ?: 0) + 1

    if (settings.enableCsvLogging) {
        logSessionToFile(data)
    }

    if (type == "normal" && state.baselineMonthsCollected >= 2) {
        checkForAnomalies(data)
    }
}

def logSessionToFile(data) {
    def fileName = getFileName()
    def line = "${data.timestamp},${data.type},${data.cycles}," +
            "${String.format('%.1f', safeToBigDecimal(data.avgOn))}," +
            "${String.format('%.1f', safeToBigDecimal(data.avgOff))}," +
            "${String.format('%.2f', safeToBigDecimal(data.runtime))}"

    def fileContent = ""
    try {
        def existingBytes = downloadHubFile(fileName)
        if (existingBytes) {
            fileContent = new String(existingBytes)
        }
    } catch (e) {
        logDebug "Creating new log file: ${fileName}"
    }

    if (!fileContent) {
        fileContent = "Time,Type,Cycles,AvgOn,AvgOff,SessionDurationMin\n"
    }

    try {
        fileContent += "${line}\n"
        uploadHubFile(fileName, fileContent.bytes)
        logDebug "Saved session to CSV"
    } catch (e) {
        log.error "Failed to write CSV: ${e.message}"
    }
}

def checkMonthRollover() {
    def nowMonth = new Date().format("yyyy-MM")
    if (state.currentMonth != nowMonth) {
        log.info "Month Rollover: ${state.currentMonth} -> ${nowMonth}"
        updateMonthlySnapshot()
        state.currentMonth = nowMonth
        state.currentMonthSessions = []
        state.stuckOnEventCountThisMonth = 0
        state.sessionsThisMonth = 0
    }
}

def updateMonthlySnapshot() {
    if (!state.currentMonthSessions) return

    def validSessions = state.currentMonthSessions.findAll { it.type == "normal" }
    if (validSessions.size() == 0) return

    validSessions.sort { it.runtime }
    def median = validSessions[ (int)(validSessions.size() / 2) ]

    def snap = [
            monthYear: new Date().parse("yyyy-MM", state.currentMonth).format("MMM yyyy"),
            cycles: median.cycles,
            avgOn: median.avgOn,
            avgOff: median.avgOff,
            stuckOnEvents: state.stuckOnEventCountThisMonth ?: 0,
            sessionsPerDay: String.format('%.1f', (state.sessionsThisMonth / 30.0)),
            anomaly: state.anomalyDetected
    ]

    state.monthlySnapshots.add(0, snap)
    if (state.monthlySnapshots.size() > 12) state.monthlySnapshots = state.monthlySnapshots.take(12)

    state.baselineMonthsCollected = (state.baselineMonthsCollected ?: 0) + 1
    calculateBaseline()
}

def calculateBaseline() {
    if (settings.lockBaseline) {
        log.info "Baseline is LOCKED. Skipping update."
        return
    }

    def list = state.monthlySnapshots.take(12)
    if (list.size() < 2) return

    def totOn = 0.0
    def totOff = 0.0
    list.each {
        totOn += safeToBigDecimal(it.avgOn)
        totOff += safeToBigDecimal(it.avgOff)
    }

    state.baselineAvgOn = totOn / list.size()
    state.baselineAvgOff = totOff / list.size()
    state.baselineCycleTime = state.baselineAvgOn + state.baselineAvgOff

    log.info "Baseline Updated: ${state.baselineCycleTime}s Cycle"
}

def checkForAnomalies(data) {
    def baseCycle = safeToBigDecimal(state.baselineCycleTime)
    if (baseCycle == 0) return

    def curCycle = safeToBigDecimal(data.avgOn) + safeToBigDecimal(data.avgOff)
    def diff = (curCycle - baseCycle).abs()
    def pct = (diff / baseCycle) * 100.0

    if (pct > anomalyThreshold) {
        def msg = "Cycle time deviated by ${String.format('%.0f', pct)}%"
        state.anomalyDetected = true
        state.anomalyMessage = msg
        log.warn "Anomaly Detected: ${msg}"
        if (anomalySwitch) anomalySwitch.on()
    }
}

// ----------------------------------------------------------------------------
//   UTILITIES
// ----------------------------------------------------------------------------

def getSystemStatus() {
    if (state.stuckOnDetected) {
        return [text: "STUCK ON ALERT", color: "#cc0000"]
    } else if (state.leftOnDetected) {
        return [text: "Cycling Detected", color: "#e67e22"]
    } else if (state.deviceOn) {
        return [text: "Pump Running", color: "#27ae60"]
    }
    return [text: "System Idle", color: "#666"]
}

def updateAppLabel() {
    def prefix = labelPrefix ?: powerMeter.displayName
    def status = getSystemStatus()
    app.updateLabel("${prefix} - ${status.text}")
}

def appButtonHandler(btn) {
    if (btn == "btnResetRecent") {
        log.info "Clearing Recent Sessions table and ending current session"
        state.recentSessions = []
        finishSession()
    } else if (btn == "btnResetHistory") {
        log.warn "‚ö†Ô∏è RESETTING ALL HISTORICAL DATA - This cannot be undone!"
        
        // Clear all historical tracking data
        state.monthlySnapshots = []
        state.currentMonthSessions = []
        state.baselineAvgOn = null
        state.baselineAvgOff = null
        state.baselineCycleTime = null
        state.baselineMonthsCollected = 0
        state.stuckOnEventCountThisMonth = 0
        state.sessionsThisMonth = 0
        state.sessionsToday = 0
        state.anomalyDetected = false
        state.anomalyMessage = null
        state.showFullHistory = false
        
        // Turn off anomaly switch if it was on
        if (anomalySwitch && anomalySwitch.currentValue("switch") == "on") {
            anomalySwitch.off()
            log.info "Turned off anomaly alert switch"
        }
        
        log.info "All historical data has been reset. CSV files remain on disk."
    }
}

def checkDayRollover() {
    def today = new Date().format("yyyy-MM-dd")
    if (state.lastSessionDate != today) {
        state.sessionsToday = 0
        state.lastSessionDate = today
    }
}

def safeToBigDecimal(val) {
    if (val == null) return BigDecimal.ZERO
    try {
        if (val instanceof BigDecimal) return val
        def clean = val.toString().replaceAll("[^\\d.-]", "")
        return clean ? new BigDecimal(clean) : BigDecimal.ZERO
    } catch (e) {
        return BigDecimal.ZERO
    }
}

def getAverage(list) {
    if (!list || list.size() == 0) return BigDecimal.ZERO
    def sum = list.collect { safeToBigDecimal(it) }.sum()
    return (sum / new BigDecimal(list.size()))
}

def getFileName() {
    def cleanName = powerMeter.displayName.replaceAll(/[^a-zA-Z0-9]/, "")
    def dateStr = new Date().format("yyyy-MM")
    return "power-cycle-${cleanName}-${dateStr}.csv"
}

def getFileManagerUrl(filename) {
    return "/local/${filename}"
}

def getOnDuration() {
    if (!state.continuousOnStart) return ""
    def sec = (now() - state.continuousOnStart) / 1000
    return formatDuration(sec)
}

def formatDuration(seconds) {
    def s = safeToBigDecimal(seconds)
    if (s < 60) return "${s.setScale(0, RoundingMode.HALF_UP)}s"
    return "${(s/60).setScale(1, RoundingMode.HALF_UP)}m"
}

def logDebug(msg) {
    if (logEnable) log.debug msg
}
